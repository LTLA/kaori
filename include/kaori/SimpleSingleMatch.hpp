#ifndef KAORI_SIMPLE_SINGLE_MATCH_HPP
#define KAORI_SIMPLE_SINGLE_MATCH_HPP

#include "ConstantTemplate.hpp"
#include "SequenceSet.hpp"
#include "VariableLibrary.hpp"
#include "utils.hpp"

#include <string>
#include <unordered_map>
#include <vector>

/**
 * @file SimpleSingleMatch.hpp
 *
 * @brief Define the `SimpleSingleMatch` class.
 */

namespace kaori {

/**
 * @brief Match a template with a single variable region.
 *
 * This class supports the most common use case for barcode matching, where a constant region has a single variable region with no restrictions on the mismatches.
 * 
 * @tparam N Size of the bitset used to represent the constant template sequence.
 * The maximum length of the template sequence is equal to `N / 4`.
 */
template<size_t N>
class SimpleSingleMatch {
public:
    /**
     * @param[in] seq Pointer to a character array containing the template sequence, see `ConstantTemplate()`.
     * @param n Length of the array pointed to by `s`.
     * @param f Should the search be performed on the forward strand of the read sequence?
     * @param r Should the search be performed on the reverse strand of the read sequence?
     * @param variable Known sequences for the single variable region in `seq`.
     * @param mismatch Maximum number of mismatches to consider across the entire template sequence.
     * @param duplicates Whether duplicate sequences allowed in `variable`, see `MismatchTrie`.
     */
    SimpleSingleMatch(const char* seq, size_t n, bool f, bool r, const SequenceSet& variable, int mismatch = 0, bool duplicates = false) : 
        num_options(variable.choices.size()),
        forward(f), 
        reverse(r),
        max_mismatches(mismatch),
        constant(seq, n, f, r)
    {
        // Exact strandedness doesn't matter here, just need the number and length.
        const auto& regions = constant.variable_regions();
        if (regions.size() != 1) {
            throw std::runtime_error("expected one variable region in the constant template");
        }

        size_t var_length = regions[0].second - regions[0].first;
        if (var_length != variable.length) {
            throw std::runtime_error("length of variable sequences (" + std::to_string(variable.length) + ") should be the same as the variable region (" + std::to_string(var_length) + ")");
        }

        if (forward) {
            forward_lib = SimpleVariableLibrary(variable, max_mismatches, false, duplicates);
        }
        if (reverse) {
            reverse_lib = SimpleVariableLibrary(variable, max_mismatches, true, duplicates);
        }
    }

public:
    /**
     * @brief State of the search on a read sequence.
     */
    struct SearchState {
        /**
         * Index of the known sequence that matches the variable region in the read sequence.
         * This will be -1 if no match was found.
         */
        int index = 0;

        /**
         * Position of the match, reported as the position on the read at the start of the constant template.
         * This should only be used if `index != -1`.
         */
        size_t position = 0;

        /**
         * Total number of mismatches, including both the constant and variable regions.
         * This should only be used if `index != -1`.
         */
        int mismatches = 0;

        /**
         * Total number of mismatches in the variable region.
         * This should only be used if `index != -1`.
         */
        int variable_mismatches = 0;

        /**
         * Whether the match was found on the reverse strand of the read sequence.
         */
        bool reverse = false;

        /**
         * @cond
         */
        typename SimpleVariableLibrary::SearchState forward_details, reverse_details;
        /**
         * @endcond
         */
    };

    /**
     * Initialize the search state for thread-safe execution.
     *
     * @return A new `SeachState()`.
     */
    SearchState initialize() const {
        return SearchState();
    }

    /**
     * Incorporate search cache optimizations from `state`, see `SimpleVariableLibrary::reduce()` for details.
     * This allows regular consolidation of optimizations across threads.
     *
     * @param state A state object generated by `initialize()`.
     * Typically this has been used in `search_first()` or `search_best()`.
     *
     * @return Optimizations from `state` are incorporated into the class.
     */
    void reduce(SearchState& state) {
        if (forward) {
            forward_lib.reduce(state.forward_details);
        }
        if (reverse) {
            reverse_lib.reduce(state.reverse_details);
        }
    }

private:
    bool has_match(int obs_mismatches) const {
        return (obs_mismatches >= 0 && obs_mismatches <= max_mismatches);
    }

    void forward_match(const char* seq, const typename ConstantTemplate<N>::MatchDetails& details, SearchState& state) const {
        auto start = seq + details.position;
        const auto& range = constant.variable_regions()[0];
        std::string curseq(start + range.first, start + range.second);
        forward_lib.match(curseq, state.forward_details, max_mismatches - details.forward_mismatches);
    }

    void reverse_match(const char* seq, const typename ConstantTemplate<N>::MatchDetails& details, SearchState& state) const {
        auto start = seq + details.position;
        const auto& range = constant.template variable_regions<true>()[0];
        std::string curseq(start + range.first, start + range.second);
        reverse_lib.match(curseq, state.reverse_details, max_mismatches - details.reverse_mismatches);
    }

public:
    /**
     * Search a read for the first match to the template with a known sequence for the variable region.
     *
     * @param[in] seq Pointer to a character array containing the read sequence.
     * @param len Length of the read sequence.
     * @param state State object, used to store the search result.
     *
     * @return Whether a search was found.
     * If `true`, `state` is filled with the details of the first match.
     */
    bool search_first(const char* seq, size_t len, SearchState& state) const {
        auto deets = constant.initialize(seq, len);
        bool found = false;
        state.index = -1;
        state.mismatches = 0;
        state.variable_mismatches = 0;

        auto update = [&](bool rev, int const_mismatches, const typename SimpleVariableLibrary::SearchState& x) -> bool {
            if (x.index < 0) {
                return false;
            }

            int total = const_mismatches + x.mismatches;
            if (total > max_mismatches) {
                return false;
            }

            found = true;
            state.position = deets.position;
            state.mismatches = total;
            state.reverse = rev;
            state.index = x.index;
            state.variable_mismatches = x.mismatches;
            return true;
        };

        while (!deets.finished) {
            constant.next(deets);

            if (forward && has_match(deets.forward_mismatches)) {
                forward_match(seq, deets, state);
                if (update(false, deets.forward_mismatches, state.forward_details)) {
                    break;
                }
            }

            if (reverse && has_match(deets.reverse_mismatches)) {
                reverse_match(seq, deets, state);
                if (update(true, deets.reverse_mismatches, state.reverse_details)) {
                    break;
                }
            }
        }

        return found;
    }

    /**
     * Search a read for the best match to the template with a known sequence for the variable region.
     * This is slower than `search_first()` but will find the matching position with the fewest mismatches.
     *
     * @param[in] seq Pointer to a character array containing the read sequence.
     * @param len Length of the read sequence.
     * @param state State object, used to store the search result.
     *
     * @return Whether a search was found.
     * If `true`, `state` is filled with the details of the best match.
     */
    bool search_best(const char* seq, size_t len, SearchState& state) const {
        auto deets = constant.initialize(seq, len);
        state.index = -1;
        bool found = false;
        int best = max_mismatches + 1;

        auto update = [&](bool rev,  int const_mismatches, const typename SimpleVariableLibrary::SearchState& x) -> void {
            if (x.index < 0) {
                return;
            }

            auto total = x.mismatches + const_mismatches;
            if (total == best) { 
                if (state.index != x.index) { // ambiguous, setting back to a mismatch.
                    found = false;
                    state.index = -1;
                }
            } else if (total < best) {
                found = true;
                best = total; 
                // A further optimization at this point would be to narrow
                // max_mismatches to the current 'best'. But this probably
                // isn't worth it.

                state.index = x.index;
                state.mismatches = total;
                state.variable_mismatches = x.mismatches;
                state.position = deets.position;
                state.reverse = rev;
            }
        };

        while (!deets.finished) {
            constant.next(deets);

            if (forward && has_match(deets.forward_mismatches)) {
                forward_match(seq, deets, state);
                update(false, deets.forward_mismatches, state.forward_details);
            }

            if (reverse && has_match(deets.reverse_mismatches)) {
                reverse_match(seq, deets, state);
                update(true, deets.reverse_mismatches, state.reverse_details);
            }
        }

        return found;
    }

private:
    size_t num_options;
    bool forward, reverse;
    int max_mismatches;

    ConstantTemplate<N> constant;
    SimpleVariableLibrary forward_lib, reverse_lib;
};

}

#endif
